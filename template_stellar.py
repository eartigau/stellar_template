from astropy.table import Table
from astropy.io import fits
import numpy as np
from scipy.interpolate import InterpolatedUnivariateSpline as IUS
from scipy.constants import c
import glob

def doppler(wave, vsys):
    """
    Apply relativistic Doppler shift to a wavelength array.

    Parameters
    ----------
    wave : array-like
        Input wavelength array.
    vsys : float
        Systemic velocity in m/s.

    Returns
    -------
    shifted_wave : array-like
        Doppler-shifted wavelength array.
    """
    # Apply the relativistic Doppler formula to shift the wavelengths
    return wave * np.sqrt((1 + vsys / c) / (1 - vsys / c))

def mk_stellar_template(rparams):
    """
    Generate Doppler-corrected stellar templates for a list of objects.

    For each object in rparams['OBJECT_SCIENCE'], this function:
      - Checks if a template already exists and skips if so.
      - Loads the FITS header and extracts the systemic velocity.
      - Reads the template FITS file for the object.
      - Applies a relativistic Doppler shift to the wavelength grid.
      - Interpolates the flux and error onto the shifted grid.
      - Masks invalid data after shifting.
      - Gathers metadata from the FITS header.
      - Writes a CSV file with a detailed comment header and the corrected data.

    Parameters
    ----------
    rparams : dict
        Dictionary containing at least:
            'DATA_DIR' : str, path to data directory
            'OBJECT_SCIENCE' : list of str, object names
    """
    sci_path = rparams['DATA_DIR']
    objs = rparams['OBJECT_SCIENCE']

    print(f"Starting stellar template creation for {len(objs)} objects...")

    for obj in objs:
        outname = f'{sci_path}/templates/Stellar_{obj}.csv'
        # Check if the template already exists
        if glob.glob(outname):
            print(f"Template for {obj} already exists, skipping creation.")
            continue

        print(f"\nProcessing object: {obj}")

        # Load FITS header for metadata and systemic velocity
        print(f"  Loading FITS header for {obj}...")
        hdr = fits.getheader(f'{sci_path}/masks/{obj}_full.fits')
        vsys = hdr['SYSTVELO']
        print(f"  Systemic velocity (vsys): {vsys:.2f} m/s")

        # Find the template FITS file for this object
        print(f"  Searching for template FITS file for {obj}...")
        print(f"  Looking in {sci_path}/templates/ for Template_*_{obj}_*.fits")
        template = glob.glob(f'{sci_path}/templates/Template_*_{obj}_*.fits')
        if not template:
            print(f"  ERROR: No template FITS file found for {obj}. Skipping.")
            continue
        print(f"  Reading template FITS file: {template[0]}")
        tbl = Table.read(template[0])

        # Extract wavelength, flux, and error arrays
        print("  Extracting wavelength, flux, and eflux arrays...")
        wave = np.array(tbl['wavelength'])
        flux = np.array(tbl['flux'])
        eflux = np.array(tbl['eflux'])

        # Mask for valid data points
        print("  Creating mask for valid data points...")
        g = np.isfinite(flux) & (flux > 0.0) & np.isfinite(eflux)

        # Interpolate flux and error onto Doppler-shifted grid
        print("  Interpolating flux and eflux onto Doppler-shifted grid...")
        flux2 = IUS(wave[g], flux[g], k=3, ext=0)(doppler(wave, vsys))
        eflux2 = IUS(wave[g], eflux[g], k=3, ext=0)(doppler(wave, vsys))
        # Interpolate the mask itself to identify valid regions after Doppler shift
        mask2 = IUS(wave, g.astype(float), k=1, ext=0)(doppler(wave, vsys))

        # Set flux and error to NaN where the mask indicates invalid data
        print("  Masking invalid data after Doppler shift...")
        flux2[mask2 < 0.5] = np.nan
        eflux2[mask2 < 0.5] = np.nan

        # List of header keys to include in the comment block
        used_keys = [
            'INSTRUME', 'DRSOBJN', 'OBJNAME', 'PP_TEFF', 'PP_TEFFS',
            'PP_SPT', 'PP_PLX', 'LBLNTMPL', 'LBL_VERS'
        ]

        # Fill missing header keys with NaN
        print("  Checking for missing header keys...")
        for key in used_keys:
            if key not in hdr:
                print(f"    Header key '{key}' missing, setting as NaN.")
                hdr[key] = np.nan

        # Calculate the median sampling in m/s/pixel
        sampling = np.nanmedian(c / (wave / np.gradient(wave)))
        print(f"  Median sampling: {sampling:.2f} m/s/pixel")

        # Build the comment block for the file header
        print("  Building comment block for file header...")
        comments = [
            f" ",
            f"This file is generated by the LBL package.",
            f"For details, visit : https://lbl.exoplanets.ca",
            f"The spectrum is corrected for its systemsic velocity.",
            f"This is the appropriate data product to constrain stellar parameters,",
            f"such as chemical composition, effective temperature, and surface gravity.",
            f" ",
            f"The data is stored in a CSV file with the following columns :",
            f" - wavelength : the wavelength in Âµm (vacuum)",
            f" - flux : relative flux, do NOT use this for absolute flux or large-scale SED",
            f" - eflux : 1-sigma dispersion of input files",
            f" ",
            f" The wavelength grid is sampled at {sampling:.2f} m/s/pixel.",
            f" This is a re-splining of the original data to a common wavelength grid.",
            f" By construction, the wavelength grid has a strictly uniform sampling in",
            f"velocity space.",
            f" ",
            f"You can read this file with Table.read('filename.csv', format='csv',comment='#')",
            f" ",
            f"        Information from the header :",
            f" ",
            f" -- object information --",
            f" ",
            f"Name [APERO] : {hdr['DRSOBJN']}",
            f"Name [header] : {hdr['OBJNAME']}",
            f"Temperature [header] : {hdr['PP_TEFF']} K",
            f"Temperature reference : {hdr['PP_TEFFS']} K",
            f"Spectral type : {hdr['PP_SPT']}",
            f"Parallax : {hdr['PP_PLX']:.2f} mas",
            f"Distance : {1000/hdr['PP_PLX']:.2f} pc",
            f" ",
            f" -- template creation --",
            f" ",
            f"Instrument : {hdr['INSTRUME']}",
            f"Number of input files : {hdr['LBLNTMPL']}",
            f"Doppler shift applied with vsys = {vsys:.2f} m/s",
            f"LBL version : {hdr['LBL_VERS']}",
            f" "
        ]
        # Add a space at the start and end of each comment for formatting
        comments = [f" {line} " for line in comments]

        # Find the maximum line length for pretty boxing
        max_length = max(len(line) for line in comments)
        # Pad all lines and add a trailing '#'
        comments = [line.ljust(max_length + 1) + '#' for line in comments]
        # Add a box of '#' at the top and bottom
        comments.insert(0, '#' * (max_length + 2))
        comments.append('#' * (max_length + 2))

        # Create the output table
        print("  Creating output table...")
        tbl_corr = Table([wave, flux2, eflux2], names=('wavelength', 'flux', 'eflux'))

        # Write the comment block and then the CSV table
        print(f"  Writing output CSV to {outname} ...")
        with open(outname, 'w') as fout:
            for line in comments:
                fout.write(f"#{line}\n")
            tbl_corr.write(fout, format='ascii.csv')
        print(f"  Done writing {outname}.")

    print("All stellar templates processed.")